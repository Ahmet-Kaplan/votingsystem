import java.nio.file.FileSystems
import java.nio.file.Files
import java.nio.file.StandardCopyOption

version = '0.6.0'

apply plugin: 'project-report'
apply plugin: 'announce'

subprojects {
	
	repositories {
	   mavenLocal()
	   mavenCentral()
	}

	apply plugin: 'announce'
	group = 'org.votingsystem'
}

ext {
	votingSystemLibrary = null
	votingToolAndroid = null
	certsDataMap = null
}

task buildAll(dependsOn:['VotingSystemLibrary:publish', ':ClientTool:distZip', 'Tests:jar', ':releaseAndroid',
                         ':buildWars']) << { }

task buildWars() {
    doLast {
        List warProjects = ['AccessControl', 'ControlCenter', 'TimeStampServer', 'Cooins']
        warProjects.each { projectDir ->
            println "building project $projectDir"
            runCommand(project, file("./$projectDir") ,["grails", "war"])
        }
    }
}

/*task installBowerComponents() {
    List warProjects = ['AccessControl', 'ControlCenter', 'Cooins']
    warProjects.each { projectDir ->
        println "building project $projectDir"
        runCommand(project, file("./$projectDir/web-app") ,["bower", "install"])
    }
}*/

task releaseAndroid () {
    doLast {
        ProcessBuilder pb  = new ProcessBuilder("gradle", "release");
        pb.directory(file("VotingToolAndroidProject"));
        Process proc = pb.start();
        proc.consumeProcessErrorStream(System.err)
        proc.consumeProcessOutputStream(System.out)
        if (proc.waitFor() != 0) {
            throw new Exception("runCommand - project: '${project.name}' - commands: 'gradle release' - failed")
        }
    }
}

def initRootCertData() {
    if(!rootProject.certsDataMap) {
        rootProject.certsDataMap = [rootCertFile:"$projectDir/$rootKeyStorePath",
                rootSubjectDN:rootSubjectDN, password:keyStorePassword]
    }
}

def initAppsCertsData() {
    initRootCertData()
    rootProject.certsDataMap = [rootCertFile:"$projectDir/$rootKeyStorePath",
            rootSubjectDN:rootSubjectDN, password:keyStorePassword]

    Map certMap = [file:"$projectDir/$testUserKeyStorePath",
            distinguishedName:rootProject.appCertDN,
            alias:rootProject.signKeyAlias, isTimeStampingCert:false]

    List certs = [certMap]
    rootProject.certsDataMap.certs = certs
}


def initWebAppsCertsData() {
    initRootCertData()
    Map accessControlMap = [file:"$projectDir/AccessControl/web-app/WEB-INF/votingsystem/AccessControl.jks",
            distinguishedName:accessControlDN, alias:accessControlCertAlias,
            isTimeStampingCert:false]

    Map controlCenterMap = [file:"$projectDir/ControlCenter/web-app/WEB-INF/votingsystem/ControlCenter.jks",
            distinguishedName:controlCenterDN, alias:controlCenterCertAlias,
            isTimeStampingCert:false]

    Map timeStampServerMap = [file:"$projectDir/TimeStampServer/web-app/WEB-INF/votingsystem/TimeStampServer.jks",
            distinguishedName:timeStampServerDN, alias:timeStampServerCertAlias,
            isTimeStampingCert:true]

    Map cooinServerMap = [file:"$projectDir/Cooins/web-app/WEB-INF/votingsystem/CooinServer.jks",
            distinguishedName:cooinServerDN, alias:cooinServerCertAlias,
            isTimeStampingCert:true]

    List certs = [accessControlMap, controlCenterMap, timeStampServerMap, cooinServerMap]

    rootProject.certsDataMap.certs = certs
}

task genWebAppsCerts() {
	doLast {
        initWebAppsCertsData()
		tasks.getByPath('VotingSystemLibrary:generateCertificates').execute()
	}
}

task genAppsCerts() {
    doLast {
        initAppsCertsData()
        tasks.getByPath('VotingSystemLibrary:generateCertificates').execute()
    }
}

//allprojects { tasks.withType(Upload){ allprojects { mustRunAfter tasks.matching {it instanceof VerificationTask } } } }
//project.tasks.each {task -> if(task.name.endsWith("AppsCerts")) {}}

task installCerts(dependsOn:['VotingSystemLibrary:publish'])  {
    doFirst { }
    doLast {
        initAppsCertsData()
        initWebAppsCertsData()
        tasks.getByPath('VotingSystemLibrary:generateCertificates').execute()
        /*project(':VotingSystemLibrary').tasks.each {task ->  println task.path}*/
    }
}

task refreshDependencies(dependsOn:['VotingSystemLibrary:publish']) << {
    runCommand(project, file("./AccessControl") ,["grails", "refresh-dependencies"])
    runCommand(project, file("./Cooins") ,["grails", "refresh-dependencies"])
    runCommand(project, file("./ControlCenter") ,["grails", "refresh-dependencies"])
    announce.announce("'$project.name' - Library Dependencies updated", "local")
}

task generateVotingSystemApps(dependsOn: [':VotingSystemLibrary:publish', ':ClientTool:distZip', ':releaseAndroid']) { }

task copyApps(dependsOn: [':generateVotingSystemApps']) {
    doLast {
        List warProjects = ['AccessControl', 'Cooins']
        warProjects.each { projectDir ->
            copyVotingSystemApps(projectDir)
        }
    }
}

def copyVotingSystemApps(projectDir) {
    file("./$projectDir/web-app/android/").mkdirs();
	File votingToolAndroid = file("./$projectDir/web-app/android/VotingToolAndroid.apk")
	if(votingToolAndroid.exists()) votingToolAndroid.delete()
	votingToolAndroid << file("VotingToolAndroidProject/VotingToolAndroid/VotingToolAndroid.apk")?.bytes
    copyClientTool(project)
}

task copyWebComponents() {
    doLast {
        List warProjects = ['AccessControl', 'ControlCenter', 'Cooins']
        warProjects.each { projectDir ->
            copyWebComponents(projectDir)
        }
    }
}

def copyWebComponents(projectDir) {
    File[] webComponents = file("./WebComponents").listFiles(new FilenameFilter() {
        public boolean accept(File dir, String fileName) {
            return fileName.startsWith("vs-")
        }
    });
    String baseDestPath = file("./$projectDir/web-app/bower_components").absolutePath
    println "copyWebComponents - baseDestPath: '${baseDestPath}'"
    for(File webComponent:webComponents) {
        copy {
            from webComponent.absolutePath
            into "$baseDestPath/${webComponent.getName()}"
        }
    }
}

def copyClientTool(project) {
    project.file("web-app/tools/").mkdirs();
    File clientToolDist = project.file("web-app/tools/${rootProject.clientToolName}.zip")
    if(clientToolDist.exists()) clientToolDist.delete()
    clientToolDist << file("ClientTool/build/distributions/${rootProject.clientToolName}.zip")?.bytes
}

task copyAppsAll(dependsOn: [':AccessControl:copyApps', 'ControlCenter:copyApps', ':Cooins:copyApps']) {}

task initDevEnvironment(dependsOn: ['VotingSystemLibrary:classes', 'initDevEnvironmentApps']) {}
task initDevEnvironmentApps(dependsOn: [':installCerts', ':AccessControl:copyApps']) {}
initDevEnvironmentApps.mustRunAfter tasks.getByPath('VotingSystemLibrary:classes')


task installVotingSystem(dependsOn: ['buildAll', 'initDevEnvironment']) {}
initDevEnvironment.mustRunAfter buildAll

def installGrailsRestDocPlugin(project) {
	String fileURL = "https://github.com/jgzornoza/GrailsRestDocPlugin/" + 
		"archive/v${grailsRestDocPluginVersion}.zip"
	File pluginFile = file("GrailsRestDocPlugin-${grailsRestDocPluginVersion}.zip")
	println "--- downloading ${fileURL}"
	ant.get(src:fileURL, dest:pluginFile)
	ant.unzip(src:pluginFile, dest:".")
	runCommand(project, file("GrailsRestDocPlugin-${grailsRestDocPluginVersion}"), ["grails", "package-plugin"])
	runCommand(project, file("GrailsRestDocPlugin-${grailsRestDocPluginVersion}"), ["grails", "maven-install"])
	project.announce.announce("GrailsRestDocPlugin installed", "local")
}

def runCommand(project, targetDir, commands) {
	ProcessBuilder pb  = new ProcessBuilder(commands);
	pb.directory(targetDir);
	Process proc = pb.start();
	proc.consumeProcessErrorStream(System.err)
	proc.consumeProcessOutputStream(System.out)
	if (proc.waitFor() != 0) {
		throw new Exception("runCommand - project: '${project.name}' - commands: ${commands} - failed")
	}
}

// This is a task that generates the gradlew scripts, allowing users to run gradle without having gradle installed
// on their system.
// This task should be run by "build master" and the resulting output committed to source control.  Its outputs include:
//  1) /gradlew which is the *NIX shell script for executing builds
//  2) /gradlew.bat which is the windows bat script for for executing builds
//  3) /wrapper which is a directory named by the "jarPath" config which contains other needed files.
task wrapper(type: Wrapper) {
	gradleVersion = '2.2.1'
}
