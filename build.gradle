version = '0.6.0'

apply plugin: 'project-report'
apply plugin: 'announce'

subprojects {
	
	repositories {
	   mavenLocal()
	   mavenCentral()
	}

	apply plugin: 'announce'
	group = 'org.votingsystem'
}

ext {
	votingToolApplet = null
	validationToolApplet = null
	votingSystemLibrary = null
	votingToolAndroid = null
	certsDataMap = null
}

task buildAll(dependsOn:['VotingSystemLibrary:publish', 'VotingToolApplet:signJar', 'ValidationToolApplet:signJar',
	 'AccessControl:war', 'ControlCenter:war', ':releaseAndroid']) << { }


task releaseAndroid () {
    doLast {
        ProcessBuilder pb  = new ProcessBuilder("gradle", "release");
        pb.directory(file("VotingToolAndroidProject"));
        Process proc = pb.start();
        proc.consumeProcessErrorStream(System.err)
        proc.consumeProcessOutputStream(System.out)
        if (proc.waitFor() != 0) {
            throw new Exception("runCommand - project: '${project.name}' - commands: ${commands} - failed")
        }
    }
}

tasks.getByPath('AccessControl:war').mustRunAfter releaseAndroid

def initRootCertData() {
    if(!rootProject.certsDataMap) {
        rootProject.certsDataMap = [rootCertFile:"$projectDir/$rootKeyStorePath",
                rootSubjectDN:rootSubjectDN, password:keyStorePassword]
    }
}

def initAppsCertsData() {
    initRootCertData()
    rootProject.certsDataMap = [rootCertFile:"$projectDir/$rootKeyStorePath",
            rootSubjectDN:rootSubjectDN, password:keyStorePassword]

    Map certMap = [file:"$projectDir/$testUserKeyStorePath",
            distinguishedName:rootProject.appCertDN,
            alias:rootProject.signKeyAlias, isTimeStampingCert:false]

    List certs = [certMap]
    rootProject.certsDataMap.certs = certs
}


def initWebAppsCertsData() {
    initRootCertData()
    Map accessControlMap = [file:"$projectDir/AccessControl/web-app/WEB-INF/cms/AccessControl.jks",
            distinguishedName:accessControlDN, alias:accessControlCertAlias,
            isTimeStampingCert:true]

    Map controlCenterMap = [file:"$projectDir/ControlCenter/web-app/WEB-INF/cms/ControlCenter.jks",
            distinguishedName:controlCenterDN, alias:controlCenterCertAlias,
            isTimeStampingCert:true]

    List certs = [accessControlMap, controlCenterMap]
    rootProject.certsDataMap.certs = certs
}

task genWebAppsCerts() {
	doLast {
        initWebAppsCertsData()
		tasks.getByPath('VotingSystemLibrary:generateCertificates').execute()
	}
}


task genAppsCerts() {
    doLast {
        initAppsCertsData()
        tasks.getByPath('VotingSystemLibrary:generateCertificates').execute()
    }
}

//allprojects { tasks.withType(Upload){ allprojects { mustRunAfter tasks.matching {it instanceof VerificationTask } } } }
//project.tasks.each {task -> if(task.name.endsWith("AppsCerts")) {}}

task installCerts()  {
    doFirst { }
    doLast {
        initAppsCertsData()
        initWebAppsCertsData()
        tasks.getByPath('VotingSystemLibrary:generateCertificates').execute()
        /*project(':VotingSystemLibrary').tasks.each {task ->  println task.path}*/
    }
}


task uploadApps(dependsOn:['uploadAccessControl', 'uploadControlCenter']) << {}

task uploadAccessControl(dependsOn:['AccessControl:war']) << {
	//ncftpput -u jgzornoza -p hola 192.168.1.5 . target/AccessControl.war
    def warFilePath = "AccessControl/target/AccessControl.war"
    File warFile = project.file(warFilePath)
    if(warFile.exists()) {
        runCommand(project, file(".") ,["ncftpput", "-u", "jgzornoza",
                "-p", "hola", "$rootProject.testServerIP", ".", warFilePath])
    } else println "${warFilePath} not found"
}

task uploadControlCenter(dependsOn:['ControlCenter:war']) << {
	//ncftpput -u jgzornoza -p hola 192.168.1.5 . target/ControlCenter.war
	def warFilePath = "ControlCenter/target/ControlCenter.war"
    File warFile = project.file(warFilePath)
    if(warFile.exists()) {
        runCommand(project, file(".") ,["ncftpput", "-u", "jgzornoza",
                "-p", "hola", "$rootProject.testServerIP", ".", warFilePath])
    } else println "${warFilePath} not found"

}

task refreshDependencies(dependsOn:['VotingSystemLibrary:publish']) << {
    runCommand(project, file("./AccessControl") ,["grails", "refresh-dependencies"])
    runCommand(project, file("./TestsWebApp") ,["grails", "refresh-dependencies"])
    runCommand(project, file("./ControlCenter") ,["grails", "refresh-dependencies"])
    announce.announce("'$project.name' - Library Dependencies updated", "local")
}

task generateVotingSystemApps(dependsOn: [':VotingToolApplet:signJar', ':ValidationToolApplet:signJar',
	':VotingSystemLibrary:publish', ':releaseAndroid']) {
}

def copyVotingSystemApps(project) {
	File appletDir = project.file("web-app/applet/");
	appletDir.mkdirs();
	File androidDir = project.file("web-app/android/");
	androidDir.mkdirs();
	
	File votingToolApplet = project.file("web-app/applet/VotingToolApplet.jar")
	if(votingToolApplet.exists()) votingToolApplet.delete()
	votingToolApplet << rootProject.votingToolApplet?.bytes
	
	File validationToolApplet = project.file("web-app/applet/ValidationToolApplet.jar")
	if(validationToolApplet.exists()) validationToolApplet.delete()
	validationToolApplet << rootProject.validationToolApplet?.bytes
	
	File votingToolAndroid = project.file("web-app/android/VotingToolAndroid.apk")
	if(votingToolAndroid.exists()) votingToolAndroid.delete()
	votingToolAndroid << file("VotingToolAndroidProject/VotingToolAndroid/VotingToolAndroid.apk")?.bytes

	copyAppletDeps(project)
}

def copyAppletDeps(project) {
	installAppletBcprov(project)
}

task installEditor(dependsOn: [':TestsWebApp:installEditor', ':AccessControl:installEditor'])  { }

task initDevEnvironment(dependsOn: ['VotingSystemLibrary:classes', 'initDevEnvironmentApps']) {}
task initDevEnvironmentApps(dependsOn: [':installCerts', ':installEditor', ':AccessControl:copyApps']) {}
initDevEnvironmentApps.mustRunAfter tasks.getByPath('VotingSystemLibrary:classes')


def installAppletBcprov(project) {
	println "installAppletBcprov - bcprovVersion '$bcprovVersion'"
	File jarFile = project.file("web-app/applet/lib/bcprov-${bcprovVersion}.jar")
	if(!jarFile.exists()) {
		jarFile.getParentFile().mkdirs()
		String jarFileURL = "http://central.maven.org/maven2/org/bouncycastle/bcprov-jdk16/1.46/bcprov-${bcprovVersion}.jar"
		println "--- downloading ${jarFileURL}"
		ant.get(src:jarFileURL, dest:jarFile)
		project.announce.announce("Bcprovider installed on project '$project.name'", "local")
	} else println "--- bcprovVersion '$bcprovVersion' already installed on project '$project.name'"
}

def installGrailsRestDocPlugin(project) {
	String fileURL = "https://github.com/jgzornoza/GrailsRestDocPlugin/" + 
		"archive/v${grailsRestDocPluginVersion}.zip"
	File pluginFile = file("GrailsRestDocPlugin-${grailsRestDocPluginVersion}.zip")
	println "--- downloading ${fileURL}"
	ant.get(src:fileURL, dest:pluginFile)
	ant.unzip(src:pluginFile, dest:".")
	runCommand(project, file("GrailsRestDocPlugin-${grailsRestDocPluginVersion}"), ["grails", "package-plugin"])
	runCommand(project, file("GrailsRestDocPlugin-${grailsRestDocPluginVersion}"), ["grails", "maven-install"])
	project.announce.announce("GrailsRestDocPlugin installed", "local")
}


def installCkeditor(project) {
	println ckeditorVersion
	File apiFile = file("libs/gckeditor_${ckeditorVersion}_standard.zip")
	if(!apiFile.exists()) {
		String fileURL = "http://download.cksource.com/CKEditor/CKEditor/CKEditor%204.2.2/ckeditor_${ckeditorVersion}_standard.zip"
		println "--- downloading ${fileURL}"
		ant.get(src:fileURL, dest:apiFile)
	}
	if(!project.file("web-app/ckeditor").exists()) {
		ant.unzip(src:apiFile, dest:project.file("web-app"))
		project.announce.announce("CKEDITOR installed on project $project.name", "local")
	} else println "--- CKEDITOR already installed on project '$project.name'"
}

def runCommand(project, targetDir, commands) {
	ProcessBuilder pb  = new ProcessBuilder(commands);
	pb.directory(targetDir);
	Process proc = pb.start();
	proc.consumeProcessErrorStream(System.err)
	proc.consumeProcessOutputStream(System.out)
	if (proc.waitFor() != 0) {
		throw new Exception("runCommand - project: '${project.name}' - commands: ${commands} - failed")
	}
}

def getLocalIP() {
    Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();
    for (NetworkInterface netint : Collections.list(nets)){
        Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();
        for (InetAddress inetAddress : Collections.list(inetAddresses)) {
            if(inetAddress.isSiteLocalAddress()) {
                String inetAddressStr = inetAddress.toString();
                while(inetAddressStr.startsWith("/"))
                    inetAddressStr = inetAddressStr.substring(1)
                return inetAddressStr
            }

        }
    }
}

// This is a task that generates the gradlew scripts, allowing users to run gradle without having gradle installed
// on their system.
// This task should be run by "build master" and the resulting output committed to source control.  Its outputs include:
//  1) /gradlew which is the *NIX shell script for executing builds
//  2) /gradlew.bat which is the windows bat script for for executing builds
//  3) /wrapper which is a directory named by the "jarPath" config which contains other needed files.
task wrapper(type: Wrapper) {
	gradleVersion = '1.8'
}
