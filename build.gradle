version = '0.7.0'

apply plugin: 'project-report'
apply plugin: 'announce'

subprojects {
	
	repositories {
	   mavenLocal()
	   mavenCentral()
	}

	apply plugin: 'announce'
	group = 'org.votingsystem'
}

ext {
    clientToolDistZip = null
	votingSystemLibrary = null
	votingToolAndroid = null
	certsDataMap = null
}

//'ClientTool:signJar' -> Needs Java8
task buildAll(dependsOn:['VotingSystemLibrary:publish', 'TimeStampServer:war',':ClientTool:copyDistZip',
                         'AccessControl:war', 'ControlCenter:war', 'Vickets:war', ':releaseAndroid']) << { }


task releaseAndroid () {
    doLast {
        ProcessBuilder pb  = new ProcessBuilder("gradle", "release");
        pb.directory(file("VotingToolAndroidProject"));
        Process proc = pb.start();
        proc.consumeProcessErrorStream(System.err)
        proc.consumeProcessOutputStream(System.out)
        if (proc.waitFor() != 0) {
            throw new Exception("runCommand - project: '${project.name}' - commands: 'gradle release' - failed")
        }
    }
}

tasks.getByPath('AccessControl:war').mustRunAfter releaseAndroid

def initRootCertData() {
    if(!rootProject.certsDataMap) {
        rootProject.certsDataMap = [rootCertFile:"$projectDir/$rootKeyStorePath",
                rootSubjectDN:rootSubjectDN, password:keyStorePassword]
    }
}

def initAppsCertsData() {
    initRootCertData()
    rootProject.certsDataMap = [rootCertFile:"$projectDir/$rootKeyStorePath",
            rootSubjectDN:rootSubjectDN, password:keyStorePassword]

    Map certMap = [file:"$projectDir/$testUserKeyStorePath",
            distinguishedName:rootProject.appCertDN,
            alias:rootProject.signKeyAlias, isTimeStampingCert:false]

    List certs = [certMap]
    rootProject.certsDataMap.certs = certs
}


def initWebAppsCertsData() {
    initRootCertData()
    Map accessControlMap = [file:"$projectDir/AccessControl/web-app/WEB-INF/cms/AccessControl.jks",
            distinguishedName:accessControlDN, alias:accessControlCertAlias,
            isTimeStampingCert:false]

    Map controlCenterMap = [file:"$projectDir/ControlCenter/web-app/WEB-INF/cms/ControlCenter.jks",
            distinguishedName:controlCenterDN, alias:controlCenterCertAlias,
            isTimeStampingCert:false]

    Map timeStampServerMap = [file:"$projectDir/TimeStampServer/web-app/WEB-INF/cms/TimeStampServer.jks",
            distinguishedName:timeStampServerDN, alias:timeStampServerCertAlias,
            isTimeStampingCert:true]

    Map vicketServerMap = [file:"$projectDir/Vickets/web-app/WEB-INF/cms/VicketServer.jks",
            distinguishedName:vicketServerDN, alias:vicketServerCertAlias,
            isTimeStampingCert:true]

    List certs = [accessControlMap, controlCenterMap, timeStampServerMap, vicketServerMap]
    rootProject.certsDataMap.certs = certs
}

task genWebAppsCerts() {
	doLast {
        initWebAppsCertsData()
		tasks.getByPath('VotingSystemLibrary:generateCertificates').execute()
	}
}


task genAppsCerts() {
    doLast {
        initAppsCertsData()
        tasks.getByPath('VotingSystemLibrary:generateCertificates').execute()
    }
}

//allprojects { tasks.withType(Upload){ allprojects { mustRunAfter tasks.matching {it instanceof VerificationTask } } } }
//project.tasks.each {task -> if(task.name.endsWith("AppsCerts")) {}}

task installCerts(dependsOn:['VotingSystemLibrary:publish'])  {
    doFirst { }
    doLast {
        initAppsCertsData()
        initWebAppsCertsData()
        tasks.getByPath('VotingSystemLibrary:generateCertificates').execute()
        /*project(':VotingSystemLibrary').tasks.each {task ->  println task.path}*/
    }
}


task uploadApps(dependsOn:['uploadAccessControl', 'uploadControlCenter']) << {}

task uploadAccessControl(dependsOn:['AccessControl:war']) << {
	//ncftpput -u jgzornoza -p hola 192.168.1.5 . target/AccessControl.war
    def warFilePath = "AccessControl/target/AccessControl.war"
    File warFile = project.file(warFilePath)
    if(warFile.exists()) {
        runCommand(project, file(".") ,["ncftpput", "-u", "jgzornoza",
                "-p", "", "$rootProject.testServerIP", ".", warFilePath])
    } else println "${warFilePath} not found"
}

task uploadControlCenter(dependsOn:['ControlCenter:war']) << {
	//ncftpput -u jgzornoza -p hola 192.168.1.5 . target/ControlCenter.war
	def warFilePath = "ControlCenter/target/ControlCenter.war"
    File warFile = project.file(warFilePath)
    if(warFile.exists()) {
        runCommand(project, file(".") ,["ncftpput", "-u", "jgzornoza",
                "-p", "", "$rootProject.testServerIP", ".", warFilePath])
    } else println "${warFilePath} not found"

}

task refreshDependencies(dependsOn:['VotingSystemLibrary:publish']) << {
    runCommand(project, file("./AccessControl") ,["grails", "refresh-dependencies"])
    runCommand(project, file("./TestsWebApp") ,["grails", "refresh-dependencies"])
    runCommand(project, file("./ControlCenter") ,["grails", "refresh-dependencies"])
    announce.announce("'$project.name' - Library Dependencies updated", "local")
}

//'ClientTool:signJar' -> Needs Java8
task generateVotingSystemApps(dependsOn: [':VotingSystemLibrary:publish', ':releaseAndroid']) {
}

def copyVotingSystemApps(project) {
    project.file("web-app/android/").mkdirs();
	File votingToolAndroid = project.file("web-app/android/VotingToolAndroid.apk")
	if(votingToolAndroid.exists()) votingToolAndroid.delete()
	votingToolAndroid << file("VotingToolAndroidProject/VotingToolAndroid/VotingToolAndroid.apk")?.bytes

    copyClientTool(project)
}

def copyClientTool(project) {
    project.file("web-app/tools/").mkdirs();
    File clientToolDist = project.file("web-app/tools/${rootProject.clientToolName}.zip")
    if(clientToolDist.exists()) clientToolDist.delete()
    clientToolDist << rootProject.clientToolDistZip?.bytes
}

task copyAppsAll(dependsOn: [':AccessControl:copyApps', 'ControlCenter:copyApps', ':Vickets:copyApps']) {}


task installEditor(dependsOn: [':TestsWebApp:installEditor', ':AccessControl:installEditor'])  { }

task initDevEnvironment(dependsOn: ['VotingSystemLibrary:classes', 'initDevEnvironmentApps']) {}
task initDevEnvironmentApps(dependsOn: [':installCerts', ':installEditor', ':AccessControl:copyApps']) {}
initDevEnvironmentApps.mustRunAfter tasks.getByPath('VotingSystemLibrary:classes')


task installVotingSystem(dependsOn: ['buildAll', 'initDevEnvironment']) {}
initDevEnvironment.mustRunAfter buildAll

def installGrailsRestDocPlugin(project) {
	String fileURL = "https://github.com/jgzornoza/GrailsRestDocPlugin/" + 
		"archive/v${grailsRestDocPluginVersion}.zip"
	File pluginFile = file("GrailsRestDocPlugin-${grailsRestDocPluginVersion}.zip")
	println "--- downloading ${fileURL}"
	ant.get(src:fileURL, dest:pluginFile)
	ant.unzip(src:pluginFile, dest:".")
	runCommand(project, file("GrailsRestDocPlugin-${grailsRestDocPluginVersion}"), ["grails", "package-plugin"])
	runCommand(project, file("GrailsRestDocPlugin-${grailsRestDocPluginVersion}"), ["grails", "maven-install"])
	project.announce.announce("GrailsRestDocPlugin installed", "local")
}


def installCkeditor(project) {
	println ckeditorVersion
	File apiFile = file("libs/gckeditor_${ckeditorVersion}_standard.zip")
	if(!apiFile.exists()) {
		String fileURL = "http://download.cksource.com/CKEditor/CKEditor/CKEditor%20${ckeditorVersion}/ckeditor_${ckeditorVersion}_standard.zip"
		println "--- downloading ${fileURL}"
		ant.get(src:fileURL, dest:apiFile)
	}
	if(!project.file("web-app/ckeditor").exists()) {
		ant.unzip(src:apiFile, dest:project.file("web-app"))
		project.announce.announce("CKEDITOR installed on project $project.name", "local")
	} else println "--- CKEDITOR already installed on project '$project.name'"
}

def runCommand(project, targetDir, commands) {
	ProcessBuilder pb  = new ProcessBuilder(commands);
	pb.directory(targetDir);
	Process proc = pb.start();
	proc.consumeProcessErrorStream(System.err)
	proc.consumeProcessOutputStream(System.out)
	if (proc.waitFor() != 0) {
		throw new Exception("runCommand - project: '${project.name}' - commands: ${commands} - failed")
	}
}

// This is a task that generates the gradlew scripts, allowing users to run gradle without having gradle installed
// on their system.
// This task should be run by "build master" and the resulting output committed to source control.  Its outputs include:
//  1) /gradlew which is the *NIX shell script for executing builds
//  2) /gradlew.bat which is the windows bat script for for executing builds
//  3) /wrapper which is a directory named by the "jarPath" config which contains other needed files.
task wrapper(type: Wrapper) {
	gradleVersion = '1.11'
}
